
var handler;

/** @constructor */
function OpenmixApplication(settings) {
    'use strict';

    /**
     * @param {OpenmixConfiguration} config
     */
    this.do_init = function(config) {
        var i;
        for (i = 0; i < settings.providers.length; i += 1) {
            config.requireProvider(settings.providers[i].alias);
        }
    };

    /**
     * @param {OpenmixRequest} request
     * @param {OpenmixResponse} response
     */
    this.handle_request = function(request, response) {
        var avail,
            candidates,
            all_reasons,
            decision_provider,
            decision_reasons = [],
            decision_ttl;

        function provider_from_alias(alias) {
            var i;
            for (i = 0; i < settings.providers.length; i += 1) {
                if (alias === settings.providers[i].alias) {
                    return settings.providers[i];
                }
            }
            return null;
        }

        function flatten(obj, property) {
            var result = {}, i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    if (obj[i].hasOwnProperty(property) && obj[i][property]) {
                        result[i] = obj[i][property];
                    }
                }
            }
            return result;
        }

        function properties_array(container, fun) {
            var i, result = [];
            for (i in container) {
                if (container.hasOwnProperty(i)) {
                    if (fun.call(null, i)) {
                        result.push(i);
                    }
                }
            }
            return result;
        }

        all_reasons = {
            got_expected_market: 'A',
            geo_override_on_country: 'B',
            unexpected_market: 'C',
			geo_override_not_available_country: 'D',
			geo_override_not_available_market: 'E'
        };

        avail = flatten(request.getProbe('avail'), 'avail');
        //console.log('avail: ' + JSON.stringify(avail));

        // First figure out the available platforms
        candidates = properties_array(avail, function(i) {
            return (avail[i] && (settings.availability_threshold <= avail[i]));
        });
        //console.log('available candidates: ' + JSON.stringify(candidates));

        if (settings.country_overrides) {
            if (settings.country_overrides[request.country]) {
                if (-1 < candidates.indexOf(settings.country_overrides[request.country])) {
                    // Override based on the request country
                    decision_provider = provider_from_alias(settings.country_overrides[request.country]);
                    decision_ttl = decision_ttl || settings.default_ttl;
                    decision_reasons.push(all_reasons.geo_override_on_country);
                } else {
                    decision_ttl = decision_ttl || settings.error_ttl;
                    decision_reasons.push(all_reasons.geo_override_not_available_country);
                }
            }

            if (!decision_provider) {
                if (settings.market_to_provider[request.market]) {
                    if (-1 < candidates.indexOf(settings.market_to_provider[request.market])) {
                        // Override based on the request market
                        decision_provider = provider_from_alias(settings.market_to_provider[request.market]);
                        decision_ttl = decision_ttl || settings.default_ttl;
                        decision_reasons.push(all_reasons.got_expected_market);
                    } else {
                        decision_ttl = decision_ttl || settings.error_ttl;
                        decision_reasons.push(all_reasons.geo_override_not_available_market);
                    }
                }
            }
        }

        if (!decision_provider) {
            decision_provider = provider_from_alias(settings.default_provider);
            decision_ttl = decision_ttl || settings.error_ttl;
            decision_reasons.push(all_reasons.unexpected_market);
        }

        response.respond(decision_provider.alias, decision_provider.cname);
        response.setTTL(decision_ttl);
        response.setReasonCode(decision_reasons.join(','));
    };
}

handler = new OpenmixApplication({
    // `providers` contains a list of the providers to be load-balanced
    // `alias` is the Openmix alias set in the Portal
    // `cname` is the CNAME or IP address to be sent as the answer when this provider is selected
    // `padding` is a penalty (or bonus) to be applied as in percentage of the actual score, e.g. 10 = 10% slower (score * 1.1)
    providers: [
        {
            alias: 'foo',
            cname: 'www.foo.com'
        },
        {
            alias: 'bar',
            cname: 'www.bar.com'
        },
        {
            alias: 'baz',
            cname: 'www.baz.com'
        }
    ],
    // The minimum availability score that providers must have in order to be considered available
    availability_threshold: 90,
    // A mapping of ISO 3166-1 country codes to provider aliases
    country_overrides: {
		'NA': 'foo',
		'EU': 'bar',
		'AF': 'baz'
	},
    // A mapping of market codes to provider aliases
    market_to_provider: {
		'ES': 'foo',
		'EG': 'bar'
	},
    // Selected if an optimal provider can't be determined
    default_provider: 'foo',
    // The TTL to be set when the application chooses an optimal provider, including geo override.
    default_ttl: 20,
    // The TTL to be set when the application chooses a potentially non-optimal provider, e.g. default or geo default.
    error_ttl: 20
});

function init(config) {
    'use strict';
    handler.do_init(config);
}

function onRequest(request, response) {
    'use strict';
    handler.handle_request(request, response);
}
